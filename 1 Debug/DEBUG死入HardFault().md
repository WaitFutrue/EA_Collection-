## [调试] ARM死机——DEBUG卡死，进入HardFault()死循环

### 🛠️ 硬件/模块

- 硬件版本：STM32F4 
- 相关代码：DSP库测试，模拟数据输入，并进行处理

### � 方案回忆

1. 当时虽然找到了官方给的例程，但是不喜欢纯英文界面，且不想程序移植

2. 所以用了AI生成的代码，如下👇
   
   ```c
   #define length 4096
   float32_t input[length]={...};
   ```

### 🔍 问题现象

- 编译没有问题，但是不能打印出结果，所以我就去DEBUG,结果卡死
- 然后我强行STOP，发现停留在一个死循环里

```c
void HardFault()
{    while(1){   }     }
```

- 再然后，我以为是长度太长，导致需要很长时间，或者数据量太大导致死机，所以我就修改里数据长度

```c
#define length 64
float32_t input[length]={...};
```

- 结果竟然可以！！！然后我测试了各种长度，发现只要我的采样长度只能是64以下，也就是打印数组长度在32以下

### ✅ 解决方案

1. 恰巧昨晚看了韦东山的DEBUG课程，但是无济于事（可能还没学会）
2. 后来翻阅资料——ARM死机的原因——发现是可能是数组的问题，于是去问AI,发现他给出的解答，和那个官方例程的定义形式一样！！！！
   
   > **AI给出的答案👇**
   > 
   > ### 可能的原因
   > 1. **内存限制**：
   >    
   >    - 嵌入式系统通常具有有限的RAM。如果你定义的数组过大，可能会超出可用内存，导致系统崩溃或“死机”。
   > 
   > 2. **栈空间大小**：
   >    
   >    - 局部变量（如你的输入输出数组）通常分配在栈上。如果栈空间不足，可能会导致栈溢出，进而引发系统崩溃。
   > 
   > 3. **硬件资源**：
   >    
   >    - 某些嵌入式芯片的硬件资源（如DMA缓冲区、中断堆栈等）也可能影响到程序的正常运行。如果这些资源被过度占用，可能导致系统不稳定。
   > 
   > ### 解决方案
   > 
   > #### 1. 使用静态或全局变量
   > 
   > 局部变量分配在栈上，容易导致栈溢出。可以尝试将大数组声明为静态或全局变量，这样它们会被分配在数据段而不是栈上。
   > 
   > ```c
   > #define length 4096
   > static float32_t input[length]={...};
   > ```
   > 
   > #### 2. 增加栈空间
   > 
   > 如果使用静态变量不可行，可以尝试增加栈空间。具体方法取决于你使用的开发环境和工具链。例如，在**Keil MDK**中，可以通过以下步骤增加栈空间：
   > 
   > - 打开项目设置。
   > - 在 "Target" 选项卡中，找到 "**Stack Size**" 并增加其值。
   > 
   > #### 3. 动态内存分配
   > 
   > 如果你的应用允许动态内存分配，可以考虑使用动态内存分配来创建数组。但请注意，这种方法在嵌入式系统中并不总是推荐，因为可能会引入碎片化问题。
   > 
   > ```c
   > #define length 4096
   > loat32_t *input = malloc(length * sizeof(float32_t) ;
   > ```

### 📚 经验教训

-  **DEBUG:**      现在终于理解了网上DUBUG大佬都是在说看堆栈

- **堆栈 ：**        对于低端的使用者，逻辑语句就够了；但是对于要**处理大数据**和做**操作系统**的大佬来说，**堆，栈**的概念相当重要

- **数组声明：** `static` 和 `malloc` 静态声明与动态函数，C语言进阶知识

### ⏰ 最近更新——2025年3月14日（计划断更）
